//AppRouter проверяет, зарегестрирован ли наш юзер
//После внедрения логики по авторизации и по сохранению токена - обернем весь наш компонет в observer('mobx-react-lite') 
//Делаем мы это для того, чтобы елемент, в зависимости от действий юзера, перерендривался в режиме реального времени (чтобы mobx мог отслеживать изменения значений состояний и при их изменении автоматически обновлять контент страницы)
//И импортироем глабальное хранилище UserStore (mobx) из Context
//Далее при помощи useState() создадим класс [loading, setLoading] который будет отвечать за то, идет ли загрузка страницы или нет
//По дефолту loading сделаем true. И пока он равен true, будем отображать какой-то значек загрузки
//В этот момент, мы паралельно отправляем запрос на проверку пользователя и после того как нам вернулся ответ, мы состояние loading делаем false
//И тогда вместо значка загрузки, у нас будет отображаться/подгрузина сама страница
//Теперь нужно написать логику отправки запроса. Она будет срабатывать только один раз, только при открытии приложения впервые
//Для этого воспользуемся хуком useEffect(). Где первым параметром, мы передадим функцию, а вторым - пустой масив зависимостей. И если он пустой, то функция отработает лишь единожды, при первом запуске приложения
//Внутри useEffect вызываем функцию check() из userAPI.js, и если она выполнилась успешно, в стейт менеджере делаем user.setUser(true) и user.setIsAuth(true)
//И после проверки пользователя, мы останавливаем значек загрузки - .finally(() => setLoading(false)

//Для чего мы это делаем? Допустим мы залогинились и сохранили наш токен в localStorage. Теперь если мы перезагрузим страницу, мы автоматически вызываем функцию check(), для проверки подлинности пользователя (делаем запрос на сервер )
//Но так как обращение к бекенду может затянуться, то мы хотим как-то уведомить пользователя, что сейчас выполняется проверка и страница сейчас в состоянии загрузки
//И после того как мы уже получим ответ от сервера, тогда мы убераем значек загрузки
//После чего, пользователь может увидеть авторизован он или ему нужно повторно залогиниться: в userSrore.js, isAuth либо меняется на true, либо остается false
//Таким образом у нас не висит статический навбар пока мы проверяем пользоветеля и возможно выполняем операцию по обновлению его токена
//И если пользователь зарегестрирован, то наш навбар уже не будут по дефолту сбрасываться до кнопки "Авторизироваться" при каждой перезагрузке страницы
//А в качестве значка загрузки, будем использовать <Spinner> из bootstrap

//Далее замемся навбаром

import './App.css';
import { BrowserRouter } from 'react-router-dom'; //Чтобы навигация по страницам была возможна - оборачиваем наше приложение
import AppRouter from './components/AppRouter';
import NavBar from './components/NavBar';
import { observer } from 'mobx-react-lite';
import React, { useContext, useState, useEffect } from 'react'
import { Context } from './index'
import { check } from './http/userAPI';
import { Spinner } from 'react-bootstrap';

const App = observer( () =>{
  const {user} = useContext(Context)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // console.log(localStorage.getItem('token')) - для проверки, что наш токен сохранен в браузере
    check().then(data => { 
      console.log(data)
      user.setUser(true)
      user.setIsAuth(true)
    }).finally(() => setLoading(false))
  }, [])

  if (loading) {
    return <Spinner animation={'grow'}/>
  }

  return (
    <BrowserRouter>
      <NavBar />
      <AppRouter />
    </BrowserRouter>
  );
})

export default App;